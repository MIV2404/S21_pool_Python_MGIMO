# Командный проект "Укрощение GPT"

## Contents

1. [Chapter I](#chapter-i) \
    1.1. [Introduction](#introduction)
2. [Chapter II](#chapter-ii) \
    2.1. [Information](#information)
3. [Chapter III](#chapter-iii) \
    3.1. [Нейросетевые API](#Нейросетевые-API) \
    3.1.1. [Text-to-Image](#Text-to-Image) \
    3.2. [HTTP-запросы](#HTTP-запросы) \
    3.3. [Telegram-бот](#Telegram-бот) \
    3.4. [Переменные окружения](#Переменные-окружения) \
    3.5. [Передача изображений](#Передача-изображений) \
    3.4. [Task 1](#task-1) \
    3.5. [Task 2](#task-2) \
    3.6. [Task 3](#task-3) \
    3.7. [Task 4](#task-4)


## Chapter I

### Introduction
Привет, студент!
Сегодня на очереди второй командный проект. Давай напомним тебе, что это значит. Командный проект подразумевает, что над задачами в этом проекте ты будешь работать не один, а в команде из четырех человек. Но и сложность задач, конечно, тоже увеличится.

## Chapter II

### Information
Хотим напомнить тебе, что наше обучение строится по принципу "равный равному" (P2P, peer-to-peer). P2P – это способ обучения, когда студенты помогают друг другу при возникновении каких-либо сложностей. Если ты столкнулся с чем-то непонятным, первым делом спроси у своих товарищей по курсу. Если ответа ты не получил, то обратись к Google. А получив ответ на свой вопрос, не забудь поделиться им с другими студентами!

## Chapter III

Чем же мы будем заниматься? В ходе этого дня тебе предстоит создать создать образовательного telegram-бота, который будет использовать несколько нейросетей! Но перед тем как начать, как это обычно бывает, – немного теории.

### Нейросетевые API

Сперва поговорим о нейросетях. Речь пойдет о двух нейросетях:
- TextCortex - для работы с текстом: перевод, генерация, перефразирование и другое.
- StableDiffusin - генерация картинок по текстовому запросу/описанию.

Настоятельно рекомендуем ознакомиться с документацией API двух нейронок:
1. [TextCortex](https://docs.textcortex.com/api)
2. [StableDiffusion](https://platform.stability.ai/docs/api-reference)

#### Text-to-Image

Text-to-Image (Text2Image) модели - это модели, которые преобразовывают запрос на естественном языке в изображение. 
Такие модели сочетают как [языковую модель](https://developers.sber.ru/portal/products/rugpt-3) (нейросеть, которая переводит текст в численное представление [вектор]), 
так и [генеративную модель](https://habr.com/ru/companies/sberbank/articles/725282/), которая по этому представлению "создаёт" изображение. Под созданием можно подразумевать сочетание прежде выученных (*не забываем, что нейросети обучают на данных*) шаблонов/паттернов.

### HTTP-запросы 

В командном проекте необходимо будет использовать HTTP-запросы (библиотека [requests](https://requests.readthedocs.io/en/latest/user/quickstart/)) аналогично заданию второго дня **(DAY02)**. Стоит обратить внимание на вид запроса в документации к API.

### Telegram-бот

Работа бота аналогична заданию от **DAY04**. Токен можно использовать с задания 4го дня (один на команду). 
Как пример бота, который генерирует изображения по запросу, можно протестировать Кандинского от СберAI (`@kandinsky21_bot`).

### Переменные окружения

В заданиях **DAY03** и **DAY04** необходимо было получить токен для работы с API (Telegram и VK). В командном проекте будет новый способ объявления токенов - *через переменные окружения* (**env**ironment variables).

Для работы необходимо иметь библиотеку `python-dotenv` ([документация](https://pypi.org/project/python-dotenv/)). Необходимо добавить API-токены и URL-адреса сервисов в файл `.env`. 

**Важно!** Файл `.env` загружать на `Gitlab` *не* надо. Необходимо проверить, что в файле `.gitignore` добавлен файл `src\.env`

### Передача изображений

Последний теоретический блок на сегодня – передача изображений. Мы с вами легко перекидываемся картинками в мессенджерах, скачиваем, загружаем в свои соц. сети, но что происходит в это время под красивым пользовательским интерфейсом? Это мы с вами сейчас и узнаем!

Как и вся информация в памяти компьютера, изображения так или иначе хранятся в виде последовательности битов. Однако сам принцип хранения информации об изображении может быть различным. Речь идет о растровых и векторных изображениях. 

**Растровые изображения** – это изображения, которые представляют собой сетку из набора пикселей (маленьких точек), каждый из которых обладает своим цветом. Растровые изображения хранятся в памяти компьютера путем выделения места в памяти для каждого пикселя. Значение цвета каждого пикселя сохраняется, обычно как комбинация значений красного, зеленого и синего (RGB). Вся сетка пикселей формирует изображение, и эта сетка последовательно сохраняется в памяти строка за строкой или столбец за столбцом для формирования изображения.

**Векторные же изображения** хранятся с использованием математических описаний форм, линий и кривых. Вместо хранения отдельных пикселей векторные изображения хранят такую информацию, как координаты, пути и атрибуты (свойства). Это позволяет масштабировать изображение без потери качества. Подробнее о векторных изображениях можно спросить у Google.

С тем, как изображения хранятся, разобрались. Теперь о том, как их передавать и получать

Сегодня тебе предстоит **получать изображения**, используя API. Поэтому давай посмотрим, как с помощью Python и библиотеки requests можно получить изображение:
```
import requests

res = requests.get("image URL") 
out = open("path\image_name.jpg", "rb") 
out.write(res.content) 
out.close()
```
В этом коде тебе все должно быть знакомым, так что просто скажем в двух словах, как он работает:
1. выполняем запрос и сохраняем ответ в `res`
2. создаем пустой файл для картинки и открываем на запись
3. res.content возвращает бинарное содержимое ответа, а мы его записываем в файл

Касаемо **отправки изображений**. Здесь мы поговорим не об API, а о том, как бот может отправлять картинки пользователю. Делается это довольно просто:
```
bot.send_photo(message.from_user.id, photo = ("Путь к файлу с фото/Загруженное в локальную переменную изображение"))
```
Команда не сильно отличается от той, что мы использовали для отправки сообщений.

На этом с теорией мы заканчиваем. Пришло время объяснить задание!

### Task 1
Общая идея проекта: разработка tg-бота, который избавит пользователя от утомительных поисков *нужного* изображения среди миллионов однотипных. 
Но поскольку нейросеть-генератор изображений "англоговорящая", то стоит позаботиться о пользователях tg-бота и предоставить возможность перевода запроса с русского языка на английский. Эту возможность можно *как включить, так и отключить*.

Перед тем как создать бота, необходимо настроить работу с нейронками (с их API, если быть точным). API-обработчик:
1. Получить токены для двух API (по одному токену на сервис для команды)
2. Хранение/считывание в конфиг-файлах
3. Выполнение запросов\* и парсинг ответов (для каждой нейронки можно делать отдельно)

\* Не стоит забывать проверять код ответа от веб-сервиса =)

### Task 2
Telegram-бот: 
1. Создание бота - меню/кнопки/интерфейсы. Должны быть подсказки как пользоваться ботом (кнопка инфо|меню|иное)
2. Обработка запросов пользователей + нажатия кнопок
3. Вывод результатов работы нейронок (перевод сообщений - если изначальный запрос на русском; генерация изображений)

### Task 3
Общая логика работы: 
1. Хранение пользовательских настроек
2. Обработка текущего состояния диалога с пользователем
3. Объединение блоков TG-бота и API-обработчиков в единую программу

### Task 4
*(Дополнение)* Генерация изображений по случайному запросу. Добавьте кнопку 'Мне повезёт!'\*\*, которая выдаёт случайное изображение пользователю.
\*\* Как пример, посмотрите на работу кнопки 'Мне повезёт!' в поисковой системе Google 🔎

>Пожалуйста, оставьте обратную связь по проекту в [форме обратной связи.](https://forms.gle/QDf1S2fYoWCwvCYc6)
